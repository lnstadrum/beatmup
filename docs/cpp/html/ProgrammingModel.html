<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Beatmup: Programming model</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Beatmup
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('ProgrammingModel.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Programming model </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Beatmup is thought as a toolset for building efficient signal and image processing pipelines.</p>
<p>This page covers briefly few main concepts of a fairly simple programming model used in Beatmup: <em>contexts</em>, <em>thread pools</em>, <em>tasks</em>, <em>jobs</em> and <em>bitmaps</em>.</p>
<h1><a class="anchor" id="secContext"></a>
Context and thread pools</h1>
<p>A <a class="el" href="classBeatmup_1_1Context.html" title="Basic class: task and memory management, any kind of static data.">Context</a> instance mainly contains one or more thread pools that can execute processing actions (tasks). At least one <a class="el" href="classBeatmup_1_1Context.html" title="Basic class: task and memory management, any kind of static data.">Context</a> instance (and quite often just one) is required to do anything in Beatmup.</p>
<p>A thread pool is a bunch of threads and a queue of tasks. Tasks are submitted by the application in a pool and are executed in order. A given thread pool can run only one task at a time, but it does so in multiple threads in parallel for speed.</p>
<p>Thread pools work asynchronously with respect to the caller code: the tasks can be submitted by the application in a non-blocking call, straight from a user interface managing thread for example. <a class="el" href="classBeatmup_1_1Context.html" title="Basic class: task and memory management, any kind of static data.">Context</a> exposes necessary API entries to check whether a specific task is completed or still waiting in the queue, to cancel a submitted task, to check exceptions thrown during task execution, etc.</p>
<p>By default, when a thread pool is created, the number of threads it hosts is inferred from the hardware concurrency: typically, it is equal to the number of logical CPU cores. This setting is likely to provide the best performance for computationally intensive tasks. The number of threads in a pool can be further adjusted by calling <a class="el" href="classBeatmup_1_1Context.html#aef95a36cb436cf42f815747ca566d677" title="Limits maximum number of threads (workers) when performing tasks in a given pool.">Context::limitWorkerCount()</a>.</p>
<h1><a class="anchor" id="secTasks"></a>
Tasks</h1>
<p>A task (instance of <a class="el" href="classBeatmup_1_1AbstractTask.html" title="Task: an operation that can be executed by multiple threads in parallel.">AbstractTask</a>) is an isolated elementary processing operation. It can run in parallel in multiple threads for speed, on CPU and/or GPU.</p>
<h2><a class="anchor" id="ssecStruct"></a>
Task structure</h2>
<p>The tasks are not intended to contain any user code. If you need a specific processing function to be implemented, much likely you need to subclass <a class="el" href="classBeatmup_1_1AbstractTask.html" title="Task: an operation that can be executed by multiple threads in parallel.">AbstractTask</a>.</p>
<p>In short, an <a class="el" href="classBeatmup_1_1AbstractTask.html" title="Task: an operation that can be executed by multiple threads in parallel.">AbstractTask</a> has three main phases:</p><ul>
<li>a phase "before processing" run in a single thread to perform the necessary prepration,</li>
<li>the main processing phase run in as many threads as possible, actually performing computatively intensive operations,</li>
<li>a phase "after processing" to clean up. The number of threads running the main phase is minimum of two values: the total number of threads in the thread pool the task is submitted to, and the maximum allowed number of threads given by the task itself.</li>
</ul>
<p>A detailed description is available in <a class="el" href="classBeatmup_1_1AbstractTask.html" title="Task: an operation that can be executed by multiple threads in parallel.">AbstractTask</a> documentation.</p>
<h2><a class="anchor" id="ssecExceptions"></a>
Exceptions handling</h2>
<p>The tasks can throw exceptions. If this happens, the thread pool that is in charge of running the failing task stores the exception internally and rethows it back to the application code, when the latter calls <a class="el" href="classBeatmup_1_1Context.html#a6eeced0b78135914ba6ad6ea8ec8a8b1" title="Checks if a specific thread pool is doing great: rethrows exceptions occurred during tasks execution,...">Context::check()</a> function.</p>
<p>It is recommended to call <a class="el" href="classBeatmup_1_1Context.html#a6eeced0b78135914ba6ad6ea8ec8a8b1" title="Checks if a specific thread pool is doing great: rethrows exceptions occurred during tasks execution,...">Context::check()</a> in a timely manner to process exceptions produced by tasks.</p>
<h2><a class="anchor" id="ssecJobs"></a>
Jobs</h2>
<p>When a task is submitted to a thread pool using <a class="el" href="classBeatmup_1_1Context.html#a35797a525ee7fc9090893be41a86c19a" title="Adds a new task to the jobs queue.">Context::submitTask()</a> function, it produces a job. A job is just a ticket number in the queue of the corresponding thread pool. <a class="el" href="classBeatmup_1_1Context.html" title="Basic class: task and memory management, any kind of static data.">Context</a> functions take it to check the task status or cancel it. In this way, the same task can be submitted several times to the same thread pool, producing several different jobs, and will then be run several times.</p>
<p>If the asynchronous behavior is not needed, a task can be run in a blocking call to <a class="el" href="classBeatmup_1_1Context.html#a2c863be3e7bdc218e307ed0235a13996" title="Performs a given task.">Context::performTask()</a>. This hides the mechanics of jobs from the user and just runs a given task.</p>
<h2><a class="anchor" id="ssecPersistent"></a>
Persistent tasks</h2>
<p>Usually, once a task is completed, it is dropped from the thread pool queue. This is referred to as the "normal mode", differently to the "persistent mode" in which the task is getting repeated until it decides to quit itself. This is convenient for rendering and playback tasks consuming signals from external sources, that are still run in a granular fashion (by frame or signal buffer) but persist until the data is fully consumed.</p>
<p><a class="el" href="classBeatmup_1_1Context.html#a5bb895de90118b9c78c73fa6f15afaeb" title="Adds a new persistent task to the jobs queue.">Context::submitPersistentTask()</a> produces a persistent job for a specific task.</p>
<h1><a class="anchor" id="secBitmaps"></a>
Bitmaps</h1>
<p>Since Beatmup is mainly oriented towards image processing, <a class="el" href="classBeatmup_1_1AbstractBitmap.html" title="A very basic class for any image.">AbstractBitmap</a> is another central class in Beatmup.</p>
<p>An <a class="el" href="classBeatmup_1_1AbstractBitmap.html" title="A very basic class for any image.">AbstractBitmap</a> is basically an image. From the application perspective it has two main implementations.</p><ul>
<li><a class="el" href="classBeatmup_1_1InternalBitmap.html" title="Bitmap whose memory is managed by the Beatmup engine.">InternalBitmap</a> is a platform-independent image managed by Beatmup itself. It is convenient to be use to exchange data between tasks.</li>
<li>Platform/frontend-dependent implementations, such as <a class="el" href="classBeatmup_1_1Android_1_1Bitmap.html" title="Wrapper of Android.Graphics.Bitmap object.">Android::Bitmap</a>, <a class="el" href="classBeatmup_1_1Android_1_1ExternalBitmap.html" title="Image coming from a SurfaceTexture (Camera or video decoder)">Android::ExternalBitmap</a>, or <a class="el" href="classBeatmup_1_1Python_1_1Bitmap.html" title="Wrapper of Android.Graphics.Bitmap object.">Python::Bitmap</a>. This is used for I/O operations with the outer world and typically implements a direct access to the pixel data without memory copy.</li>
</ul>
<p>Beatmup is thought to be lightweight and dependency-free. For this reason it does not incorporate image decoding/encoding features: it cannot natively read and write JPEG or PNG files for example. This is not a problem when using Beatmup within an application where all the typical means of loading and storing images are accessible through the corresponding <a class="el" href="classBeatmup_1_1AbstractBitmap.html" title="A very basic class for any image.">AbstractBitmap</a> implementations. Also, for debugging purposes and minimal I/O capabilities Beatmup supports reading and writing BMP files.</p>
<h2><a class="anchor" id="ssecDevice"></a>
CPU and GPU</h2>
<p>Beatmup uses GPU to process images when possible. In order to mix efficiently CPU and GPU processing, Beatmup can store the same image in CPU memory, GPU memory or both. This naturally implies pixel transfer operations. Internally, Beatmup hides this from the user as much as possible and only performs the pixel data transfer when needed. However, when it comes to exchange the image data with the application code, the user typically needs to make sure the CPU version of the image (the one accessible with the platform-specific bitmaps outside of the Beatmup environment) is up-to-date with respect to the GPU version used by Beatmup.</p>
<ul>
<li><a class="el" href="classBeatmup_1_1AbstractBitmap.html#aa75c59e782c58e24b0bdf65c0829ec2d">AbstractBitmap::isUpToDate()</a> function allows to check if the bitmap is up-to-date for a specific device (GPU or CPU).</li>
<li>If it needs to be updated, <a class="el" href="classBeatmup_1_1Swapper.html">Swapper</a> is an <a class="el" href="classBeatmup_1_1AbstractTask.html" title="Task: an operation that can be executed by multiple threads in parallel.">AbstractTask</a> copying the image data between CPU and GPU. Namely, <a class="el" href="classBeatmup_1_1Swapper.html#afcab58d37045901ad672f5edeaff09a1" title="Copies bitmap from GPU memory to RAM.">Swapper::pullPixels()</a> updates the CPU version of an image after it is processed, so that it can be consumed by the applications using the platform-dependent bitmaps.</li>
<li>Some tasks offer special tools to ensure that CPU has access to the bitmap content up-to-date, e.g <a class="el" href="classBeatmup_1_1SceneRenderer.html#a4e39a4d16eaf09fc33f2910eee15d870" title="Specifies whether the output image data is pulled from GPU to CPU memory every time the rendering is ...">SceneRenderer::setOutputPixelsFetching()</a>.</li>
</ul>
<h2><a class="anchor" id="ssecGpuGarbage"></a>
GPU garbage collection</h2>
<p>When a bitmap is destroyed in the application code, its GPU storage is not destroyed immediately. This is due to the fact that destroying a texture representing the bitmap content in the GPU memory needs to be done in a thread that has access to the GPU, which is one of the threads in the thread pool. The textures of destroyed bitmaps are marked as unused anymore and put into a "GPU trash bin". The latter is emptied by calling <a class="el" href="classBeatmup_1_1GL_1_1RecycleBin.html#a848e8385178b599926528cda15cdfb04" title="Empty the bin destroying all the items in a GPU-aware thread.">GL::RecycleBin::emptyBin()</a> function on a recycle bin object instance returned by <a class="el" href="classBeatmup_1_1Context.html#a4918f978bff1efeca73aca904109329e">Context::getGpuRecycleBin()</a>. Note that the recycle bin instance is only allocated is the GPU is actually used within the given <a class="el" href="classBeatmup_1_1Context.html" title="Basic class: task and memory management, any kind of static data.">Context</a>.</p>
<p>In applications doing repeated allocations and deallocations of images (e.g., processing video frames in a loop), it is recommended to empty the GPU recycle bin periodically in the described way in order to prevent running out of memory.</p>
<h1><a class="anchor" id="secMultistage"></a>
Multi-stage processing</h1>
<p>The thread pools make easy running several tasks one after the other. However, when the same pattern of tasks is needed to be run repeatedly, Beatmup offers a technique to put multiple tasks together into a single compound task, <a class="el" href="classBeatmup_1_1Multitask.html" title="Conditional multiple tasks execution.">Beatmup::Multitask</a>. This enables designing complex application-specific processing pipelines.</p>
<p>A multitask is a pipeline of tasks processing some data in a multi-stage fashion. It can simply host multiple tasks and run them in order, without explicitly submitting them into a thread pool. It also implements a set of repetition policies allowing to skip some stages at the beginning of the pipeline, if no changes is made to the input data and parameters with respect to the previous run, for example. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Nov 21 2023 13:54:27 for Beatmup by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
